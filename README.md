# Портфолио 

В портфолио собраны проекты, выполненные во время обучения на образовательной платформе [GeekBrains](https://gb.ru/) по специальности Тестировщик.

## Тестирование

### 1. Тест-дизайн и тест-аналитика

#### 1.1 Работа с требованиями 
  Задание: Изучить [требования](https://docs.google.com/document/d/1qDu7Z0OdmZsVSSC-Hvw_L3s0YKTT8d3t4jy6b8q7v5A/edit?usp=sharing), сделать их декомпозицию и составить по требованиям mind-map
 
 Решение: [Диаграмма связей](https://drive.google.com/file/d/1ARHVwp8BCZtIBhC7TpPxgY9HuisFFEwT/view?usp=sharing)
 
 ![mind-map](https://github.com/user-attachments/assets/28297058-b3c8-442e-bd44-2372b01dc69c)
 
 
#### 1.2 Классы эквивалентности
 Задание: Выделить классы эквивалентности для [формы оплаты](https://test-stand.gb.ru/seminar_stands/payform/index.html) по [требованиям](https://docs.google.com/document/d/1qDu7Z0OdmZsVSSC-Hvw_L3s0YKTT8d3t4jy6b8q7v5A/edit?usp=sharing?gid=842307886#gid=842307886). Для каждого класса определить линейный он или нелинейный.

Решение:  [Классы эквивалентности для формы оплаты](https://docs.google.com/spreadsheets/d/1BmnRL6iPyQpGPa8ffP-pzazKK8cDackw-kbXu4my-K4/edit?usp=sharing#gid=842307886)


#### 1.3 Попарное тестирование
  Задание: Составить попарные наборы данных для [формы оплаты](https://test-stand.gb.ru/seminar_stands/payform/index.html) по [требованиям](https://docs.google.com/document/d/1qDu7Z0OdmZsVSSC-Hvw_L3s0YKTT8d3t4jy6b8q7v5A/edit?usp=sharing)

  Решение: [Попарные наборы данных для формы оплаты](https://docs.google.com/spreadsheets/d/1BmnRL6iPyQpGPa8ffP-pzazKK8cDackw-kbXu4my-K4/edit?usp=sharing#gid=240194035)
  
  Для составления попарных наборов использовался онлайн - инструмент  [Pairwise Online Tool](https://pairwise.teremokgames.com/)   и выделенные выше классы эквивалентности								

#### 1.4 Граничные згачения и доменный анализ
 Задание: Определить граничные значения и составить таблицу доменного анализа для [формы оплаты](https://test-stand.gb.ru/seminar_stands/payform/index.html) по [требованиям](https://docs.google.com/document/d/1qDu7Z0OdmZsVSSC-Hvw_L3s0YKTT8d3t4jy6b8q7v5A/edit?usp=sharing)

  Решение: [Доменный анализ](https://docs.google.com/spreadsheets/d/1BmnRL6iPyQpGPa8ffP-pzazKK8cDackw-kbXu4my-K4/edit?usp=sharing#gid=61184320)

  В качестве классов эквивалентности  и попарных наборов были использованы значения пп. [1.2](https://docs.google.com/spreadsheets/d/1BmnRL6iPyQpGPa8ffP-pzazKK8cDackw-kbXu4my-K4/edit?usp=sharing#gid=842307886), [1.3](https://docs.google.com/spreadsheets/d/1BmnRL6iPyQpGPa8ffP-pzazKK8cDackw-kbXu4my-K4/edit?usp=sharing#gid=240194035)

  #### 1.5 Диаграммы и таблицы переходов состояний
  Задание: Составить диаграмму переходов состояний по [требованиям](https://docs.google.com/document/d/1Jid1zcMXuMA3JEgUHSdZoSpbJDWVawjmrAaQnfScN0w/edit?usp=sharing). Составить таблицу переходов состояний, опираясь на построенную диаграмму и требования.
  
  Решение: [Диаграмма состояний и таблица переходов](https://docs.google.com/spreadsheets/d/1vlAwgcOSWS1VNS2oOfQ48WII2MkKmKk_cXv5lQLDjc4/edit?usp=sharing)

  

  ### 2. Тестирование API

  #### 2.1 Rest API
   Задание : Ознакомиться с ТЗ на раздел “Создание Публикации”, написать чек-лист на проверку запроса на создание поста, создать коллекцию в Postman “Create Post”, написать тесты на проверку всех значений из ответа и status code, завести баг-репорты. Предоставить отчет о тестировании функционала “Создание публикации”.
   
   Решение: [Отчет о тестировании функционала Создание публикации](https://docs.google.com/document/d/1O26MapMzibcWm6lynNk24z7NxHQmO98lj8d25C4P7HA/edit?usp=sharing)


   ### 3. Тестирование web-приложений

   #### 3.1 Основы тестирования WEB-приложений
   Задание: Ознакомиться с [ТЗ на экран Профиль](https://drive.google.com/file/d/12BQfwckqiQVn1eLRKAEx_ovGTir_CpW-/view?usp=sharing). Протестировать функционал на экране Профиль на WEB. На найденные дефекты завести баг-репорты. 

   Решение: [Чек-листы и баг-репорты, заведенные в результате тестирования функционала на экране Профиль на WEB](https://docs.google.com/document/d/1Jid1zcMXuMA3JEgUHSdZoSpbJDWVawjmrAaQnfScN0w/edit?usp=sharing)

   #### 3.2 Chrome DevTools
   Задание: провести тестирование функционала социальной сети для тестировщиков согласно плану.

   Решение: [Отчет по результатам тестирования функционала социальной сети для тестировщиков](https://docs.google.com/document/d/1lZf196wtjhV6ela2c15sWjY1Qz1si5VE/edit?usp=sharing&ouid=117441247688904656363&rtpof=true&sd=true)
   
   #### 3.3 Тестирование форм
   Задание:  Составить чек-листы по [ТЗ](https://docs.google.com/document/d/1wKKgZLR3w5AVPbEV8GPyBsUrw5Q515TZCMsB93PPxrg/edit?usp=sharing) на форму обратной связи, провести тестирование согласно чек-листам. 
             Завести баг-репорты на найденные дефекты.

   Решение: [Чек-листы и баг-репорты, заведенные в результате тестирования формы обратной связи](https://docs.google.com/spreadsheets/d/1FQEvlTY_yG7zBu3vqCh6_DMoFvF8b6WIPk__XYH1FIE/edit?usp=sharing)

   ### 4. Тестирование мобильных приложений

   Задание: Провести тестирование блока “Лента и отображение поста” нашего приложения с помощью мобильной фермы.

1. Изучить [требования](https://drive.google.com/file/d/160urUA-PnU_vcKfcOhuIaJypJbfjYByM/view?usp=sharing) к блоку “Лента и отображение” (стр 6 - 11 требований)
2. Составить тест-кейсы на тестирование
3. Провести тестирование по чек листу с помощью мобильной фермы Samsung Remote Test Lab. 
4. При наличии багов - завести баг-репорт. К каждому багу прикладывайте скриншоты/видео/логи.
5. Сформировать отчет о тестировании функциональности.

   Решение: [Тест-кейсы, чек-листы и  баг-репорты на блок "Лента и отображение" социальной сети для тестировщиков](https://docs.google.com/spreadsheets/d/1fnSzUkALVyCrnaP7H8E1JDilSr8nyxzT7tq6Oj-YtKM/edit?usp=sharing)

   

   ## Базы данных и SQL

1. У сущности «пользователи» имеются следующие поля(атрибуты):
id – идентификатор;
firstname – имя;
lastname - фамилия;
email - адрес электронной почты.

У сущности «заявки на дружбу» имеются следующие поля(атрибуты):
initiator_user_id – инициатор;
target_user_id – получатель;
status - статус;
requested_at - дата создания;
updated_at - дата последнего обновления.

Друзья — это пользователи у которых имеется соответствующая запись (заявка) в сущности «заявки на дружбу» и в атрибуте status данной сущности указано значение 'approved'.

 Задание : Найдите количество друзей у каждого пользователя. Выведите для каждого пользователя идентификатор пользователя, имя, 
фамилию и количество друзей cnt. Сортировка выводимых записей в порядке возрастания идентификатора пользователя. 
```
CREATE TABLE users
(	
    id INT NOT NULL PRIMARY KEY,
    firstname VARCHAR(45) not null,
    lastname VARCHAR(45) not null,
    email VARCHAR(45) not null
);

INSERT INTO users (id, firstname, lastname, email)
VALUES  ('1', 'ivan', 'ivanov', 'ролджщ'),
        ('2', 'petr', 'petrov', '1254hkk'),
        ('3', 'kate', 'smitt', 'kk44'),
	('4', 'jak', 'mouth', 'hjk55'),
	('5', 'jon', 'swep', 'bjk55'),
	('6', 'sam', 'polder', '56632'),
	('7', 'anna', 'sergeeva', '55kk'),
	('8', 'pol', 'linder', 'gh55');

CREATE TABLE friend_requests
(initiator_user_id int,
 target_user_id int,
 status VARCHAR(45),
 requested_at VARCHAR(45),
 updated_at VARCHAR(45)
);

INSERT INTO friend_requests ( initiator_user_id, target_user_id, status, requested_at, updated_at)
VALUES (1, 2, 'requested',  '2023-01-06 07:33:23', null), 
  (1, 3, 'approved', '2023-01-07 01:53:07', '2023-01-18 16:22:56'),
  (4, 1, 'approved', '2023-01-08 15:57:26', '2023-01-15 18:12:00'),
  (5, 2, 'approved', '2023-01-08 18:22:00', '2023-01-14 08:25:00'),
  (6, 3, 'unfriended', '2023-01-09 1', null);
  
INSERT INTO friend_requests ( initiator_user_id, target_user_id, status, requested_at, updated_at)
VALUES (6, 2, 'approved',  '2023-01-06 07:33:23', '2023-01-07 01:53:07'), 
  (5, 3, 'approved', '2023-01-27 01:53:07', '2023-01-28 16:22:56');
  
INSERT INTO friend_requests ( initiator_user_id, target_user_id, status, requested_at, updated_at)
VALUES (5, 4, 'approved',  '2022-01-06 07:33:23', '2023-01-07 01:53:07'), 
  (4, 3, 'approved', '2022-01-27 01:53:07', '2023-01-28 16:22:56');
  
select * FROM users u
left join friend_requests f on u.id = f.initiator_user_id
union all
select * FROM users u
right join friend_requests f on u.id = f.initiator_user_id;
  
  
select u.id, u.firstname, u.lastname, count(f.status) as cnt from users u 
left join friend_requests f on (u.id = f.initiator_user_id or u.id = f.target_user_id) 
and f.status = 'approved'
group by u.id
order by u.id;
```

2. База данных содержит сущности:
users – пользователи;
messages – сообщения;
friend_requests – заявки на дружбу;
communities – сообщества;
users_communities – пользователи сообществ;
media_types – типы медиа;
media – медиа;
likes – лайки;
profiles – профили пользователя.

У сущности «пользователи» имеются следующие поля(атрибуты):
id – идентификатор;
firstname – имя;
lastname - фамилия;
email - адрес электронной почты.

У сущности «профиль пользователя» имеются следующие поля(атрибуты):
user_id – идентификатор;
gender – пол;
birthday - дата рождения;
photo_id - аватарка;
hometown - город.

Атрибут «пол» сущности «профиль пользователя» может принимать следующие значения:
'f' - женский;
'm' - мужской.

У сущности «лайки» имеются следующие поля(атрибуты): id – идентификатор;
user_id – пользователь, который поставил лайк;
media_id - медиа, который лайкнули.

У сущности «медиа» имеются следующие поля(атрибуты):
id – идентификатор;
user_id – пользователь – владелец медиа;
body - содержимое;
filename – ссылка на файл;
created_at - дата создания;
updated_at - дата последнего обновления.

 Задание 2.1 : Найдите общее количество лайков, которые получили пользователи женского пола. 

```
CREATE TABLE profiles
(id INT,
 gender varchar(2)
);

INSERT INTO profiles (id, gender) values 
(1, 'f'),
(2, 'm'),
(3, 'f'),
(4, 'f'),
(5, 'm'),
(6, 'f');
(7, 'f');

CREATE TABLE likes
(id INT,
user_id int,
media_id int
);

INSERT INTO likes (id, user_id, media_id ) values 
(1, 1, 3),
(2, 1, 5),
(3, 3, 6),
(4, 6, 4),
(5, 2, 7),
(6, 4, 5),
(7, 5, 5);

CREATE TABLE media
(id INT not null,
user_id int not null
);

INSERT INTO media (id, user_id ) values 
(1, 1),
(2, 5),
(3, 6),
(4, 4),
(5, 7),
(6, 2),
(7, 3);

SELECT * FROM likes l
left JOIN media m on l.media_id = m.id
left JOIN profiles p on m.user_id = p.id;

SELECT count(p.id) FROM likes l
left JOIN media m on l.media_id = m.id
left JOIN profiles p on m.user_id = p.id
where gender = 'f';
```

 Задание 2.2 : Найдите количество лайков, которые поставили пользователи женского пола и мужского пола.
Выведите название пола (преобразовав значение атрибута f в женский, а значение ‘m` - мужской) и количество, поставленных лайков, 
применив к количеству лайков сортировку по убыванию.

```
SELECT
case 
when gender = 'f'
then 'женский'
else 'мужской'
end
as gender, 
count(p.id) as cnt
FROM profiles p 
right JOIN likes l on l.user_id = p.id
group by p.gender
order by count(gender) desc;

SELECT * FROM likes l
left JOIN profiles p on l.user_id = p.id;
```

Задание 2.3: Найти количество сообщений, отправленных каждым пользователей. В зависимости от количества отправленных сообщений рассчитать ранг пользователей, первое место присвоив пользователю(ям) с наибольшим количеством отправленных сообщений. Вывести полученный ранг, имя, фамилия, пользователя и кол-во отправленных сообщений. Выводимый список необходимо отсортировать в порядке возрастания ранга.

```
CREATE TABLE users
(	
    id INT NOT NULL PRIMARY KEY,
    firstname VARCHAR(45) not null,
    lastname VARCHAR(45) not null,
    email VARCHAR(45) not null
);

INSERT INTO `hw5`.`users` (`id`, `firstname`, `lastname`, `email`) VALUES ('1', 'ivan', 'ivanov', 'ролджщ');
INSERT INTO `hw5`.`users` (`id`, `firstname`, `lastname`, `email`) VALUES ('2', 'petr', 'petrov', '1254hkk');
INSERT INTO `hw5`.`users` (`id`, `firstname`, `lastname`, `email`) VALUES ('3', 'kate', 'smitt', 'kk44');
INSERT INTO `hw5`.`users` (`id`, `firstname`, `lastname`, `email`) VALUES ('4', 'jak', 'mouth', 'hjk55');
INSERT INTO `hw5`.`users` (`id`, `firstname`, `lastname`, `email`) VALUES ('5', 'jon', 'swep', 'bjk55');
INSERT INTO `hw5`.`users` (`id`, `firstname`, `lastname`, `email`) VALUES ('6', 'sam', 'polder', '56632');
INSERT INTO `hw5`.`users` (`id`, `firstname`, `lastname`, `email`) VALUES ('7', 'anna', 'sergeeva', '55kk');
INSERT INTO `hw5`.`users` (`id`, `firstname`, `lastname`, `email`) VALUES ('8', 'pol', 'linder', 'gh55');

CREATE TABLE messadges
(	
	id INT not null PRIMARY KEY,
    from_user_id int not null,
    to_user_id int not null,
    body VARCHAR(45) not null,
    created_at VARCHAR(45) not null   
);

INSERT INTO `hw5`.`messadges` (`id`, `from_user_id`, `to_user_id`, `body`, `created_at`) VALUES ('1', '1', '2', 'jkk', '2024-03-13');
INSERT INTO `hw5`.`messadges` (`id`, `from_user_id`, `to_user_id`, `body`, `created_at`) VALUES ('2', '1', '4', 'hjjj', '2024-03-09');
INSERT INTO `hw5`.`messadges` (`id`, `from_user_id`, `to_user_id`, `body`, `created_at`) VALUES ('3', '2', '5', 'ghjh', '2023-12-09');
INSERT INTO `hw5`.`messadges` (`id`, `from_user_id`, `to_user_id`, `body`, `created_at`) VALUES ('4', '8', '5', 'jkk', '2024-01-12');
INSERT INTO `hw5`.`messadges` (`id`, `from_user_id`, `to_user_id`, `body`, `created_at`) VALUES ('5', '5', '7', 'ghjh', '2022-08-30');
INSERT INTO `hw5`.`messadges` (`id`, `from_user_id`, `to_user_id`, `body`, `created_at`) VALUES ('6', '6', '1', 'hjj', '2021-11-08');
INSERT INTO `hw5`.`messadges` (`id`, `from_user_id`, `to_user_id`, `body`, `created_at`) VALUES ('7', '7', '3', 'jkli', '2022-09-18');
INSERT INTO `hw5`.`messadges` (`id`, `from_user_id`, `to_user_id`, `body`, `created_at`) VALUES ('8', '6', '8', 'rrt', '2022-01-12');
INSERT INTO `hw5`.`messadges` (`id`, `from_user_id`, `to_user_id`, `body`, `created_at`) VALUES ('9', '1', '2', 'xcc', '2024-02-15');
INSERT INTO `hw5`.`messadges` (`id`, `from_user_id`, `to_user_id`, `body`, `created_at`) VALUES ('10', '2', '6', 'hhj', '2020-12-09');

SELECT 
dense_rank() OVER(order by count(m.to_user_id) desc) as 'rank_mes',
u.id, firstname, lastname, count(m.to_user_id)  as count_mes
from users u
left join messadges m on u.id = m.from_user_id
group by u.id;
```

Задание 2.4: Получите список сообщений, отсортированных по возрастанию даты отправки. Вычислите разность между соседними значениями дат отправки. Разности выразите в минутах. Выведите идентификатор сообщения, дату отправки, дату отправки следующего сообщения и разницу даты отправки соседних сообщений.

```
select *from messadges;

select id, created_at,
lead(created_at) over() as cnt
from messadges;

select id, created_at,
lead(created_at) over() as cnt, TIMESTAMPDIFF(MINUTE, created_at, lead(created_at) over()) as dif_time
from messadges;
```

3. Задание: Собрать дэшборд, в котором содержится информация о максимальной задолженности в каждом банке, а также средний размер процентной ставки в каждом банке в зависимости от сегмента и количество договоров.

```
CREATE table bank (
    TB Varchar(1),
    id_client int,
    id_dog int,
    osz int,
    procent_rate int,
    rating int,
    segment varchar(10)
);

INSERT into bank VALUES 
('A', 1, 111, 100, 6, 10, 's'),
('A', 1, 222, 150, 6, 10, 's'),
('A', 2, 333, 50, 9, 15, 'm'),
('B', 1, 444, 200, 7, 10, 's'),
('B', 3, 555, 1000, 5, 16, 'c'),
('B', 4, 666, 500, 10, 20, 'c'),
('B', 4, 777, 10, 12, 17, 'm'),   
('C', 5, 888, 20, 11, 21, 'm'),  
('C', 5, 999, 200, 9, 13, 's');

SELECT *,
	max(osz) OVER (partition by TB) AS MAX_osz,
    avg(procent_rate) over (partition by TB, segment) as "ср.%-ая ставка",
    count(id_dog) over() as 'кол-во договоров'
FROM bank;


CREATE table tasks (
	id_task int,
    event VARCHAR(10),
    data_event Date
);

INSERT into tasks values
(1, 'Open', '2020-02-01'),
(1, 'To_1_line', '2020-02-02'),
(1, 'To_2_line', '2020-02-03'),
(1, 'Successful', '2020-02-04'),
(1, 'Close', '2020-02-05'),
(2, 'Open', '2020-03-01'),
(2, 'To_1_line', '2020-03-02'),
(2, 'Denied', '2020-03-03'),
(3, 'Open', '2020-04-01'),
(3, 'To_1_line', '2020-04-02'),
(3, 'To_2_line', '2020-04-03');

SELECT *, lead(event,1, 'end') over(partition by id_task) as 'next_event',
  lead(data_event, 1, '2099-01-01') over(partition by id_task) as 'next_data_event' 
from tasks;

CREATE table bank_revision (
	TB Varchar(1),
    DEP VARCHAR(10),
    count_revision int
);

INSERT into bank_revision VALUES
('A', 'Corp', 100),
('A', 'Rozn', 47),
('A', 'IT', 86),
('B', 'Corp', 70),
('B', 'Rozn', 65),
('B', 'IT', 58),
('C', 'CORP', 42),
('C', 'Rozn', 40),
('C', 'IT', 63),
('D', 'CORP', 95),
('D', 'Rozn', 120),
('D', 'IT', 85),
('E', 'CORP', 70),
('E', 'Rozn', 72),
('E', 'IT', 80),
('F', 'CORP', 66),
('F', 'Rozn', 111),
('F', 'IT', 33);

SELECT ROW_NUMBER() OVER(order by count_revision desc) as 'порядковый номер',
	TB, DEP, count_revision,
    RANK() OVER(order by count_revision desc) as 'rank',
    DENSE_RANK() OVER(order by count_revision desc) as 'dense_rank',
    ntile(3) OVER() as 'ntitle'
 FROM bank_revision;
  
 WITH ds as (SELECT *, 
	RANK() OVER(partition by TB order by count_revision desc) as 'rank_bank'
 FROM bank_revision)
 SELECT * FROM ds;
  
   WITH ds as (SELECT *, 
	RANK() OVER(partition by TB order by count_revision desc) as 'rank_bank'
 FROM bank_revision)
 SELECT * FROM ds
  WHERE rank_bank = 2;
```
